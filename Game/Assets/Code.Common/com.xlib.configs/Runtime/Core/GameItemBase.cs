using System.Diagnostics.CodeAnalysis;
using Sirenix.OdinInspector;
using UnityEngine;
using XLib.Configs.Contracts;
using XLib.Configs.Sheets.Contracts;
using XLib.Core.Reflection;
using XLib.Core.Utils;

namespace XLib.Configs.Core {

	public abstract partial class GameItemBase : GameItemCore {
		private string _assetName;

		private IGameDatabase _gameDatabase;

#if UNITY_EDITOR
		public IGameDatabase GameDatabase => UnityAppConstants.isPlaying ? _gameDatabase : GameDatabase_Editor.GetDatabase();
		public IGameDatabase GameDatabaseForEditor => GameDatabase_Editor.GetDatabase();
#else
		public IGameDatabase GameDatabase => _gameDatabase;
#endif

		[InfoBox("@ConfigDescription()", InfoMessageType.Info, "@ConfigDescription() != null", GUIAlwaysEnabled = true)]
		[GUIColor(0.8f, 0.8f, 0.4f)]
		[SerializeField, PropertyOrder(-2), HideLabel, Title("@" + nameof(FileName)), AutoGeneratedGuid, HideInInlineEditors]
		protected ItemId _id;

		[SuppressMessage("ReSharper", "UnusedMember.Global")]
		protected string ConfigDescription() => GetType().GetAttribute<ItemDescriptionAttribute>()?.Description ?? null;

		public override ItemId Id => _id;

		public override string FileName { get => this == null ? string.Empty : (string.IsNullOrEmpty(_assetName) ? base.name : _assetName); set => _assetName = value; }
		public new string name => _assetName; // берем из копии, тк обращении к имени в Unity возможно только в основном потоке 

		public override void Init(IGameDatabase gameDatabase) {
			_gameDatabase = gameDatabase;
			_assetName = base.name;
		}

		public override void Dispose() { }

		protected virtual void OnValidate() {
			_assetName = base.name;
		}
	}

}